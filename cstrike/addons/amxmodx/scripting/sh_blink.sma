// BLINK!
// "Teleport" from War3FT
// Author: Geesu
// Ported by Evileye

/* CVARS - copy and paste to shconfig.cfg

//Blink
blink_level 5
blink_cooldown 15				//Cooldown time between blinks
blink_failcooldown 2			//Cooldown on fail
blink_delay 10					//Cooldown on round start
blink_protection 1				//Check if user is in an invalid location in a map
blink_dizziness 1				//Type of dizziness

*/

//---------- User Changeable Defines --------//


// 1 = send another plugins information about cooldown, 0 = don't send
#define SEND_COOLDOWN 1


//------- Do not edit below this point ------//

#include <amxmodx>
#include <superheromod>

// GLOBAL VARIABLES
new gHeroID
new gHeroName[] = "Blink"
new bool:gHasBlink[SH_MAXSLOTS+1]
new const gBlinkSound[] = "shmod/blinkarrival.wav"
new gShockwaveSprite
new gBlueflare2Sprite
//new bool:g_isPlanting[SH_MAXSLOTS+1]
new blink_cooldown, blink_failcooldown, blink_delay
new blink_protection, blink_dizziness 
new Float:roundStartTime

// Used to make sure a spawn point isn't used for another player
//#define TOTAL_SPAWNS	64
//new g_iSpawnReserved[TOTAL_SPAWNS];
//new g_iSpawnInc = 0;

#define XPOS				0
#define YPOS				1
#define ZPOS				2
#define TELEPORT_RADIUS		50
#define TE_BEAMCYLINDER		21
#define	TASK_BLINKSTUCK		92816
#define TASK_TELEPORT		92817
#define TASK_RESETSPAWNS	92818

// New team ID defines
#define TEAM_T		1
#define TEAM_CT		2

#if SEND_COOLDOWN
new Float:BlinkUsedTime[SH_MAXSLOTS+1]
#endif
//----------------------------------------------------------------------------------------------
public plugin_init()
{
	// Plugin Info
	register_plugin("SUPERHERO Blink", "1.0", "Geesu")

	// DO NOT EDIT THIS FILE TO CHANGE CVARS, USE THE SHCONFIG.CFG
	new pcvarLevel = register_cvar("blink_level", "0")
	blink_cooldown = register_cvar("blink_cooldown", "15.0")
	blink_failcooldown = register_cvar("blink_failcooldown", "2.0")
	blink_delay = register_cvar("blink_delay", "10.0")
	blink_protection = register_cvar("blink_protection", "1")
	blink_dizziness	= register_cvar("blink_dizziness", "1")

	// FIRE THE EVENT TO CREATE THIS SUPERHERO!
	gHeroID = sh_create_hero(gHeroName, pcvarLevel)
	sh_set_hero_info(gHeroID, "Teleportation", "Teleport to where you are currently aiming at")
	sh_set_hero_bind(gHeroID)
	
	register_event("HLTV", "event_new_round", "a", "1=0", "2=0")  
}
//----------------------------------------------------------------------------------------------
public plugin_precache()
{
	precache_sound(gBlinkSound)
	gShockwaveSprite = precache_model("sprites/shockwave.spr")
	gBlueflare2Sprite = precache_model("sprites/blueflare2.spr")
}
//----------------------------------------------------------------------------------------------
#if SEND_COOLDOWN
public sendBlinkCooldown(id)
{
	new cooldown
	if (gPlayerInCooldown[id])
		cooldown = floatround( get_pcvar_num(blink_cooldown) - get_gametime() + BlinkUsedTime[id] + 0.4 )
	else
		cooldown = -1
	return cooldown
}
#endif
//----------------------------------------------------------------------------------------------
public sh_hero_init(id, heroID, mode)
{
	if ( gHeroID != heroID ) return

	switch(mode) {
		case SH_HERO_ADD: {
			gHasBlink[id] = true
		}

		case SH_HERO_DROP: {
			gHasBlink[id] = false
		}
	}

	sh_debug_message(id, 1, "%s %s", gHeroName, mode ? "ADDED" : "DROPPED")
}
//----------------------------------------------------------------------------------------------
public sh_client_spawn(id)
{
	gPlayerInCooldown[id] = false
	
	if ( get_gametime() < roundStartTime + get_pcvar_float(blink_delay) )
	{
		new Float:cooldown = get_pcvar_float( blink_delay )
		sh_set_cooldown(id, cooldown)
		#if SEND_COOLDOWN
		BlinkUsedTime[id] = get_gametime() - get_pcvar_num(blink_cooldown) + cooldown
		#endif
	}
}
//----------------------------------------------------------------------------------------------
public event_new_round()
{
	roundStartTime = get_gametime()
}
//----------------------------------------------------------------------------------------------
public sh_hero_key(id, heroID, key)
{
	if ( gHeroID != heroID || sh_is_freezetime() || !is_user_alive(id) ) return

	if ( key != SH_KEYDOWN ) return
	
	if ( gPlayerInCooldown[id] ) {
		sh_sound_deny(id)
		return
	}
	/*
	// User can't use ultimate while planting or defusing!
	if ( g_isPlanting[id] )
	{
		client_print( id, print_center, "%L", id, "BLINK_FAILED_BOMB_PLANTING" );
		return;
	}
	*/
	if ( get_user_weapon(id) == 6 )		// If carrying C4 then stop planting
		client_cmd( id, "-attack" );
		
	new vOldLocation[3], vNewLocation[3]
	
	// Get the player's current location
	get_user_origin( id, vOldLocation );
	
	// Get where the player is looking (where the player will teleport)
	get_user_origin( id, vNewLocation, 3 );
	
	// Play the blink sound!
	emit_sound( id, CHAN_STATIC, gBlinkSound, 1.0, ATTN_NORM, 0, PITCH_NORM );

	// If we teleport them back, make sure they don't get teleported into the ground
	vOldLocation[ZPOS] += 15;

	// Change coordinates to make sure player won't get stuck in the ground/wall
	vNewLocation[XPOS] += ( ( vNewLocation[XPOS] - vOldLocation[XPOS] > 0 ) ? -50 : 50 );
	vNewLocation[YPOS] += ( ( vNewLocation[YPOS] - vOldLocation[YPOS] > 0 ) ? -50 : 50 );
	vNewLocation[ZPOS] += 40;			

	
	// Set up some origins for some special effects!!!
	new vCenterOrigin[3], vAxisOrigin[3];
	vCenterOrigin[0]	= vOldLocation[0];
	vCenterOrigin[1]	= vOldLocation[1];
	vCenterOrigin[2]	= vOldLocation[2] + 10;
	vAxisOrigin[0]		= vOldLocation[0];
	vAxisOrigin[1]		= vOldLocation[1];
	vAxisOrigin[2]		= vOldLocation[2] + 10 + TELEPORT_RADIUS;
	
	// Lets create some beam cylinders!
	Create_TE_BEAMCYLINDER( vOldLocation, vCenterOrigin, vAxisOrigin, gShockwaveSprite, 0, 0, 3, 60, 0, 255, 255, 255, 255, 0 );
	
	// Modify our effects a bit for another cylinder
	vCenterOrigin[2]	+= 80;
	vAxisOrigin[2]		+= 80;
	
	// And draw another cylinder!!!
	Create_TE_BEAMCYLINDER( vOldLocation, vCenterOrigin, vAxisOrigin, gShockwaveSprite, 0, 0, 3, 60, 0, 255, 255, 255, 255, 0 );

	// Planting the bomb then teleporting = bad, lets stop this...
	client_cmd( id, "-use" );

	// Then lets try to slay some people...
	if ( get_pcvar_num( blink_protection ) )
	{

		// Lets go ahead and make this check before they teleport...
		if ( HU_ULT_BlinkProtection( id, vNewLocation ) )
		{
			// ULT_ResetCooldown( id, get_pcvar_num( CVAR_wc3_ult_cooldown ) );
			new Float:cooldown = get_pcvar_float( blink_failcooldown ) * 2
			sh_set_cooldown(id, cooldown)
			#if SEND_COOLDOWN
			BlinkUsedTime[id] = get_gametime() - get_pcvar_num(blink_cooldown) + cooldown
			#endif

			return;
		}
	}

	// Teleport the player!!!
	set_user_origin( id, vNewLocation );

	// Check if Blink landed you in a wall, if so, abort
	new parm[5];
	parm[0] = id;
	parm[1] = vOldLocation[0];
	parm[2] = vOldLocation[1];
	parm[3] = vOldLocation[2];
	parm[4] = vNewLocation[2];
	
	// [FS#65]
	set_task( 0.1, "_HU_ULT_BlinkStuck", TASK_BLINKSTUCK + id, parm, 5 );
	
	// ULT_ResetCooldown( id, get_pcvar_num( CVAR_wc3_ult_cooldown ) );
	new Float:cooldown = get_pcvar_float( blink_cooldown )
	sh_set_cooldown(id, cooldown)
	#if SEND_COOLDOWN
	BlinkUsedTime[id] = get_gametime()
	#endif

	emit_sound( id, CHAN_STATIC, gBlinkSound, 1.0, ATTN_NORM, 0, PITCH_NORM );

	return;
}
//----------------------------------------------------------------------------------------------
// Function will check to see if a user is stuck in a wall
public _HU_ULT_BlinkStuck( parm[] )
{

	new id = parm[0]	 

	if ( !is_user_connected(id) )
	{
		return;
	}

	new vOldLocation[3], vOrigin[3];

	vOldLocation[0] = parm[1];
	vOldLocation[1] = parm[2];
	vOldLocation[2] = parm[3];

	get_user_origin( id, vOrigin );
	
	// Then the user is stuck :/
	if ( parm[4] == vOrigin[2] )
	{

		//set_hudmessage( 255, 255, 10, -1.0, -0.4, 1, 0.5, BLINK_COOLDOWN, 0.2, 0.2, 5 );
		set_hudmessage( 255, 208, 0, -1.0, 0.85, 0, 6.0, 0.5, 0.1, 0.5, -1 );
		show_hudmessage( id, "%L", id, "BLINK_FAILED_BAD_DESTINATION" );
		
		// This will try to move the user back - if this fails then they will be teleported back to their spawn instead of left stuck!
		SHARED_Teleport( id, vOldLocation );

		// ULT_ResetCooldown( id, floatround(BLINK_COOLDOWN) );
		new Float:cooldown = get_pcvar_float( blink_failcooldown )
		sh_set_cooldown(id, cooldown)
		#if SEND_COOLDOWN
		BlinkUsedTime[id] = get_gametime() - get_pcvar_num(blink_cooldown) + cooldown
		#endif
	}

	// Otherwise they teleported correctly!
	else
	{

		// Sprays white bubbles everywhere
		new vStartOrigin[3];
		vStartOrigin[0] = vOrigin[0];
		vStartOrigin[1] = vOrigin[1];
		vStartOrigin[2] = vOrigin[2] + 40;
		
		Create_TE_SPRITETRAIL( vStartOrigin, vOrigin, gBlueflare2Sprite, 30, 10, 1, 50, 10 );

		// Flash the player
		if ( get_pcvar_num( blink_dizziness ) == 1 )
		{
			sh_screen_fade(id, 6.0, 0.5, 0, 0, 255, 180)
			
		}

		// Lets just flash them with a nice white screen :)
		else
		{
			sh_screen_fade(id, 6.0, 0.5, 0, 255, 255, 255)
		}
	}	
	
	return;
}
//----------------------------------------------------------------------------------------------
// Function will make sure the user isn't in an invalid location in a map
HU_ULT_BlinkProtection( id, vOrigin[3] )
{

	new bool:bSlay = false;
	new Float:fOrigin[3];
	
	// Convert origin to float
	IVecFVec( vOrigin, fOrigin );
	
	// User shouldn't be teleporting into the sky!
	if ( point_contents( fOrigin ) == CONTENTS_SKY )
	{
		bSlay = true;
	}
	
	/*
	// Get the current map name
	new szMapName[32];
	get_mapname( szMapName, 32 );

	
	// Only do these checks if we're in CS/CZ
	if ( !bSlay )
	{
		new x = vOrigin[0];
		new y = vOrigin[1];
		new z = vOrigin[2];
		
		// Don't teleport too high
		if ( equali( szMapName, "de_dust" ) )
		{
			if ( z > 220 )
			{
				bSlay = true;
			}
		}

		else if ( equali( szMapName, "awp_assault" ) )
		{
			if( z > 520 && y > 2400 && y < 2600 )
			{
				bSlay = true;
			}
		}

		else if ( equali( szMapName, "de_dust_cz" ) )
		{
			if ( z > 220 )
			{
				bSlay = true;
			}
		}

		else if ( equali( szMapName, "de_aztec_cz" ) )
		{
			if ( z > 300 )
			{
				bSlay = true;
			}
		}

		else if ( equali( szMapName, "cs_assault_upc" ) )
		{
			if( z > 650 )
			{
				bSlay = true;
			}
		}

		else if ( equali( szMapName, "de_aztec" ) )
		{
			if( z > 300 )
			{
				bSlay = true;
			}
		}

		else if ( equali( szMapName, "de_cbble" ) || equali( szMapName, "de_cbble_cz" ) )
		{
			if ( z > 315 )
			{
				if ( ! ( ( x > -1320 && x < -1150 ) && ( y > 2600 && y < 2900 ) ) )
				{
					bSlay = true;
				}
			}           
		}

		else if ( equali( szMapName, "cs_assault" ) )
		{
			if ( z > 700 )
			{
				bSlay = true;
			}
		}

		else if ( equali( szMapName, "cs_militia" ) || equali( szMapName, "cs_militia_cz" ) )
		{
			if ( z > 500 )
			{
				bSlay = true;
			}
		}

		else if ( equali( szMapName, "cs_italy" ) )
		{
			if ( z > -220 && y < -2128 )
			{
					bSlay = true;
			}
			else if( z > 250 )
			{
				if ( ( x < -1000 && x > -1648 ) && ( y > 1900 && y < 2050 ) )
				{
					bSlay = true;
				}
				else if ( ( x < -1552 && x > -1648 ) && ( y > 1520 && y < 2050 ) )
				{
					bSlay = true;
				}
			}
		}

		else if ( equali( szMapName, "cs_italy_cz" ) )
		{
			if ( y > 2608 )
			{
				bSlay = true;
			}
		}

		else if ( equali( szMapName, "de_dust2" ) )
		{
			if ( z > 270 )
			{
				bSlay = true;
			}
		}

		else if ( equali( szMapName, "de_dust2_cz" ) )
		{
			if ( z > 270 )
			{
				bSlay = true;
			}
		}

		else if ( equali( szMapName, "fy_dustworld" ) )
		{
			if ( z > 82 )
			{
				bSlay = true;
			}
		}

		else if ( equali( szMapName, "fy_pool_day" ) )
		{
			if ( z > 190 )
			{
				bSlay = true;
			}
		}

		else if ( equali( szMapName, "as_oilrig" ) )
		{
			if ( x > 1700 )
			{
				bSlay = true;
			}
		}
	}

	
	// For some reason bSlay is always true on this map, but you should be able to teleport anywhere
	if ( equali( szMapName, "cs_mice_final" ) )
	{
		bSlay = false;
	}

	*/
	// Slay the user!!!
	if ( bSlay )
	{
		sh_chat_message(id, gHeroID, "%L", id, "BLINK_SLAIN_FOR_TELEPORTING" );
		//user_kill( id, 1 );
	}

	return bSlay;
}
//----------------------------------------------------------------------------------------------
public Create_TE_SPRITETRAIL(start[3], end[3], iSprite, count, life, scale, velocity, random ){

	message_begin( MSG_BROADCAST,SVC_TEMPENTITY)
	write_byte( TE_SPRITETRAIL )
	write_coord( start[0] )				// start position (X)
	write_coord( start[1] )				// start position (Y)
	write_coord( start[2] )				// start position (Z)
	write_coord( end[0] )				// end position (X)
	write_coord( end[1] )				// end position (Y)
	write_coord( end[2] )				// end position (Z)
	write_short( iSprite )				// sprite index
	write_byte( count )					// count
	write_byte( life)					// life in 0.1's
	write_byte( scale)					// scale in 0.1's
	write_byte( velocity )				// velocity along vector in 10's
	write_byte( random )				// randomness of velocity in 10's
	message_end()
}
//----------------------------------------------------------------------------------------------
public Create_TE_BEAMCYLINDER(origin[3], center[3], axis[3], iSprite, startFrame, frameRate, life, width, amplitude, red, green, blue, brightness, speed){

	message_begin( MSG_PAS, SVC_TEMPENTITY, origin )
	write_byte( TE_BEAMCYLINDER )
	write_coord( center[0] )			// center position (X)
	write_coord( center[1] )			// center position (Y)
	write_coord( center[2] )			// center position (Z)
	write_coord( axis[0] )				// axis and radius (X)
	write_coord( axis[1] )				// axis and radius (Y)
	write_coord( axis[2] )				// axis and radius (Z)
	write_short( iSprite )				// sprite index
	write_byte( startFrame )			// starting frame
	write_byte( frameRate )				// frame rate in 0.1's
	write_byte( life )					// life in 0.1's
	write_byte( width )					// line width in 0.1's
	write_byte( amplitude )				// noise amplitude in 0.01's
	write_byte( red )					// color (red)
	write_byte( green )					// color (green)
	write_byte( blue )					// color (blue)
	write_byte( brightness )			// brightness
	write_byte( speed )					// scroll speed in 0.1's
	message_end()
}
//----------------------------------------------------------------------------------------------
/*public on_BombPlanting( id )
{
	g_isPlanting[id] = true;
}
//----------------------------------------------------------------------------------------------
public on_BombStopPlanting( id )
{
	g_isPlanting[id] = false;
}*/
//----------------------------------------------------------------------------------------------
// This will teleport a user to a location and test to make sure they were actually moved there
SHARED_Teleport( id, vOrigin[3] )
{
	// Increase so user doesn't get stuck in ground
	vOrigin[2] += 15;

	// Attempt to move the user
	set_user_origin( id, vOrigin );

	new iParm[4];
	iParm[0] = vOrigin[0];
	iParm[1] = vOrigin[1];
	iParm[2] = vOrigin[2];
	iParm[3] = id;

	// Set up the parameters
	set_task( 0.1, "_SHARED_Teleport", TASK_TELEPORT + id, iParm, 4 );
}
//----------------------------------------------------------------------------------------------
public _SHARED_Teleport( parm[] )
{
	new id = parm[3];
	new vOrigin[3];
	
	get_user_origin( id, vOrigin );


	// User is stuck, lets teleport them back to their spawn
	if ( vOrigin[2] == parm[2] )
	{
		// Find a spawn - ignore team reversal
		new iSpawnEnt = SHARED_FindFreeSpawn( id, false );
		
		// We can move the user yay!
		if ( iSpawnEnt > 0 )
		{
			new Float:fSpawnOrigin[3], vOrigin[3];
			
			// Get the origin of the spawn point
			entity_get_vector( iSpawnEnt, EV_VEC_origin, fSpawnOrigin );

			// Convert float vector to int vector
			FVecIVec( fSpawnOrigin, vOrigin );
			
			// Move the user
			SHARED_Teleport( id, vOrigin );

			sh_chat_message(id, gHeroID, "%L", id, "BLINK_STUCK_MOVING" );
		}

		// We can't move the user - that sux0rsz
		else
		{
			sh_chat_message(id, gHeroID, "%L", id, "BLINK_STUCK_SORRY" );
		}
	}
}
//----------------------------------------------------------------------------------------------
// Find a free spawn!
SHARED_FindFreeSpawn( id, bReverseTeam = false )
{

	new iPlayersInVicinity, iSpawnID, iEntList[1], vOrigin[3];
	new ent = -1;
	new Float:fSpawnOrigin[3];
	new Float:fVicinity = 96.0;
	new bool:bFound = false;
	
	new iTeam = get_user_team( id );

	// Reverse the team IDs (i.e. Mole would want this)
	if ( bReverseTeam )
	{
		iTeam = ( ( iTeam == TEAM_CT ) ? TEAM_T : TEAM_CT );
	}

	// Need to determine which spawn point to look for based on the user's team
	iSpawnID = ( ( iTeam == TEAM_CT ) ? 0 : 1 );

	// Loop through each ent until we find a spawn entity that we want
	do {
		new szSpawnEnt[2][32]
		copy( szSpawnEnt[0], 31, "info_player_start" );
		copy( szSpawnEnt[1], 31, "info_player_deathmatch" );
		ent = find_ent_by_class( ent, szSpawnEnt[iSpawnID] );
		
		// Valid ent found
		if ( ent != 0 )
		{
			entity_get_vector( ent, EV_VEC_origin, fSpawnOrigin );
			
			// Convert float vector to int vector
			FVecIVec( fSpawnOrigin, vOrigin );

			// Check to see if there are players in this spawn
			iPlayersInVicinity = find_sphere_class( 0, "player", fVicinity, iEntList, 1, fSpawnOrigin );
			
			// We have a free spawn!!
			if ( iPlayersInVicinity == 0 )
			{

				/*// Make sure it isn't reserved
				if ( !SHARED_SpawnReserved( ent ) )
				{

					// Then we need to reserve it :)
					g_iSpawnReserved[g_iSpawnInc++] = ent;
				*/	
					// We have a free spawn we can quit!
					bFound = true;
				//}
			}
		}
	}
	while ( ent && !bFound )
	
	// Reset the spawn points...
	/*
	if ( !task_exists( TASK_RESETSPAWNS ) )
	{
		set_task( 0.3, "_SHARED_SpawnReset", TASK_RESETSPAWNS );
	}*/

	// Failed, nothing found
	if ( !bFound )
	{
		return -1;
	}
	
	// Otherwise we found something!
	return ent;
}
//----------------------------------------------------------------------------------------------
/*
// Reset our reserved spawn points
public _SHARED_SpawnReset()
{
	new i;
	
	g_iSpawnInc = 0;
	for ( i = 0; i < TOTAL_SPAWNS; i++ )
	{
		g_iSpawnReserved[i] = 0;
	}
}

// Determine if this entity is reserved for another player
bool:SHARED_SpawnReserved( ent )
{
	new i;

	for ( i = 0; i < g_iSpawnInc; i++ )
	{
		if ( g_iSpawnReserved[i] == ent )
		{
			return true;
		}
	}

	return false;
}*/